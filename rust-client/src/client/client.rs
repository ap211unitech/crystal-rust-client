//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Submerge Crystal API v1
//! Source: /Users/arjunporwal/Documents/Helikon/submerge/submerge-crystal/api-spec/submerge-crystal-api.json
//! Version: 1.0.0
//! Generated by `oas3-gen v0.23.5`
//!
//! REST API for Submerge Crystal, the core indexer component of Submerge.
//! 
//! Submerge API endpoints are grouped under five resource sets:
//! - Blocks
//! - Calls
//! - Events
//! - Extrinsics
//! - Genesis
//! - Metadata
//! - Traces
//! 
//! Public API is limited by 5 requests per second.
//! Request query parameters use `snake_case`; response fields use `camelCase`.

use anyhow::Context;
use reqwest::{Client, Url};
#[allow(unused_imports)]
use reqwest::multipart::{Form, Part};
#[allow(unused_imports)]
use reqwest::header::HeaderValue;
use validator::Validate;
use super::types::*;
pub const BASE_URL: &str = "https://coretime-polkadot.crystal.submerge.io/api/v1";
#[derive(Debug, Clone)]
pub struct SubmergeCrystalApiV1Client {
    pub client: Client,
    pub base_url: Url,
}
impl SubmergeCrystalApiV1Client {
    /// Create a client using the OpenAPI `servers[0]` URL.
    #[must_use]
    pub fn new() -> Self {
        Self {
            client: Client::builder().build().expect("client"),
            base_url: Url::parse(BASE_URL).expect("valid base url"),
        }
    }
    /// Create a client with a custom base URL.
    pub fn with_base_url(base_url: impl AsRef<str>) -> anyhow::Result<Self> {
        Ok(Self {
            client: Client::builder().build().context("building reqwest client")?,
            base_url: Url::parse(base_url.as_ref()).context("parsing base url")?,
        })
    }
    /// Create a client from an existing `reqwest::Client`.
    pub fn with_client(
        base_url: impl AsRef<str>,
        client: Client,
    ) -> anyhow::Result<Self> {
        let url = Url::parse(base_url.as_ref()).context("parsing base url")?;
        Ok(Self { client, base_url: url })
    }
    ///Get blocks
    ///
    ///Returns all blocks from the database that satisfy the query parameters. It will return a paginated response, ordered descending by block number.
    ///
    ///GET /blocks
    pub async fn get_blocks(
        &self,
        request: GetBlocksRequest,
    ) -> anyhow::Result<GetBlocksResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetBlocksRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get blocks by reference
    ///
    ///If a hash is passed, returns the matching block. If a number is passed, gives the blocks by that number - could be multiple blocks if there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}
    pub async fn get_blocks_by_reference(
        &self,
        request: GetBlocksByReferenceRequest,
    ) -> anyhow::Result<GetBlocksByReferenceResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetBlocksByReferenceRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get block calls
    ///
    ///If a hash is passed, returns the calls for the matching block. If a number is passed, gives the calls for the blocks with that number - could be multiple blocks if there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/calls
    pub async fn get_calls_by_block_reference(
        &self,
        request: GetCallsByBlockReferenceRequest,
    ) -> anyhow::Result<GetSubCallsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("calls");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetCallsByBlockReferenceRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get block events
    ///
    ///If a hash is passed, returns the events for the matching block. If a number is passed, gives the events for the block with that number - could be multiple blocks if there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/events
    pub async fn get_events_by_block_reference(
        &self,
        request: GetEventsByBlockReferenceRequest,
    ) -> anyhow::Result<GetEventsByExtrinsicHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("events");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventsByBlockReferenceRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get block events by index
    ///
    ///Returns the events in the given block at the given index. It can return multiple events if a number is passed and there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/events/{event_index}
    pub async fn get_events_by_block_reference_and_index(
        &self,
        request: GetEventsByBlockReferenceAndIndexRequest,
    ) -> anyhow::Result<GetEventsByBlockReferenceAndIndexResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("events")
            .push(&request.path.event_index.to_string());
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventsByBlockReferenceAndIndexRequest::parse_response(response)
            .await?;
        Ok(parsed)
    }
    ///Get block extrinsics
    ///
    ///If a hash is passed, returns the extrinsics for the matching block. If a number is passed, gives the extrinsis for the block by that number - could be multiple blocks if there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/extrinsics
    pub async fn get_extrinsics_by_block_reference(
        &self,
        request: GetExtrinsicsByBlockReferenceRequest,
    ) -> anyhow::Result<GetExtrinsicsByBlockReferenceResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("extrinsics");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetExtrinsicsByBlockReferenceRequest::parse_response(response)
            .await?;
        Ok(parsed)
    }
    ///Get block extrinsics by index
    ///
    ///Returns the extrinsics in the given block at the given index. It can return multiple extrinsics if a number is passed and there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/extrinsics/{extrinsic_index}
    pub async fn get_extrinsics_by_block_reference_and_index(
        &self,
        request: GetExtrinsicsByBlockReferenceAndIndexRequest,
    ) -> anyhow::Result<GetExtrinsicsByBlockReferenceAndIndexResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("extrinsics")
            .push(&request.path.extrinsic_index.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetExtrinsicsByBlockReferenceAndIndexRequest::parse_response(
                response,
            )
            .await?;
        Ok(parsed)
    }
    ///Get block extrinsic calls
    ///
    ///Returns the calls for extrinsic in a block by block reference and 0-based extrinsic index.
    ///
    ///GET /blocks/{block_ref}/extrinsics/{extrinsic_index}/calls
    pub async fn get_calls_by_block_reference_and_extrinsic_index(
        &self,
        request: GetCallsByBlockReferenceAndExtrinsicIndexRequest,
    ) -> anyhow::Result<GetSubCallsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("extrinsics")
            .push(&request.path.extrinsic_index.to_string())
            .push("calls");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetCallsByBlockReferenceAndExtrinsicIndexRequest::parse_response(
                response,
            )
            .await?;
        Ok(parsed)
    }
    ///Get block extrinsic events
    ///
    ///Returns the events for extrinsic in a block by block reference and 0-based extrinsic index.
    ///
    ///GET /blocks/{block_ref}/extrinsics/{extrinsic_index}/events
    pub async fn get_events_by_block_reference_and_extrinsic_index(
        &self,
        request: GetEventsByBlockReferenceAndExtrinsicIndexRequest,
    ) -> anyhow::Result<GetEventsByExtrinsicHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("extrinsics")
            .push(&request.path.extrinsic_index.to_string())
            .push("events");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventsByBlockReferenceAndExtrinsicIndexRequest::parse_response(
                response,
            )
            .await?;
        Ok(parsed)
    }
    ///Get block traces
    ///
    ///If a hash is passed, returns the traces for the matching block. If a number is passed, returns the traces for the blocks with that number - could be multiple blocks if there's a pruned block in that slot.
    ///
    ///GET /blocks/{block_ref}/traces
    pub async fn get_traces_by_block_reference(
        &self,
        request: GetTracesByBlockReferenceRequest,
    ) -> anyhow::Result<GetTracesByBlockReferenceResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("blocks")
            .push(&request.path.block_ref.to_string())
            .push("traces");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetTracesByBlockReferenceRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get calls
    ///
    ///Returns all calls from the database that satisfy the query parameters. It will return a paginated response, ordered descending by block number, then call id.
    ///
    ///GET /calls
    pub async fn get_calls(
        &self,
        request: GetCallsRequest,
    ) -> anyhow::Result<GetCallsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetCallsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get call by hash
    ///
    ///Returns the call by its hash.
    ///
    ///GET /calls/{call_hash}
    pub async fn get_call_by_hash(
        &self,
        request: GetCallByHashRequest,
    ) -> anyhow::Result<GetCallByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls")
            .push(&request.path.call_hash.to_string());
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetCallByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get call arguments
    ///
    ///Returns the arguments of a runtime call by its hash.
    ///
    ///GET /calls/{call_hash}/args
    pub async fn get_call_args_by_hash(
        &self,
        request: GetCallArgsByHashRequest,
    ) -> anyhow::Result<GetCallArgsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls")
            .push(&request.path.call_hash.to_string())
            .push("args");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetCallArgsByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get call extrinsic
    ///
    ///Returns the extrinsic of a call by call hash.
    ///
    ///GET /calls/{call_hash}/extrinsic
    pub async fn get_call_extrinsic_by_hash(
        &self,
        request: GetCallExtrinsicByHashRequest,
    ) -> anyhow::Result<GetExtrinsicByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls")
            .push(&request.path.call_hash.to_string())
            .push("extrinsic");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetCallExtrinsicByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get parent call
    ///
    ///Returns a parent call by the sub call's hash.
    ///
    ///GET /calls/{call_hash}/parent
    pub async fn get_parent_call_by_hash(
        &self,
        request: GetParentCallByHashRequest,
    ) -> anyhow::Result<GetCallByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls")
            .push(&request.path.call_hash.to_string())
            .push("parent");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetParentCallByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get sub calls
    ///
    ///Returns sub calls call by a parent call's hash.
    ///
    ///GET /calls/{call_hash}/subs
    pub async fn get_sub_calls_by_hash(
        &self,
        request: GetSubCallsByHashRequest,
    ) -> anyhow::Result<GetSubCallsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("calls")
            .push(&request.path.call_hash.to_string())
            .push("subs");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetSubCallsByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get events
    ///
    ///Returns all events from the database that satisfy the query parameters. It will return a paginated response, ordered descending by block number and ascending event index.
    ///
    ///GET /events
    pub async fn get_events(
        &self,
        request: GetEventsRequest,
    ) -> anyhow::Result<GetEventsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("events");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get event by hash
    ///
    ///Returns the event by its hash.
    ///
    ///GET /events/{event_hash}
    pub async fn get_event_by_hash(
        &self,
        request: GetEventByHashRequest,
    ) -> anyhow::Result<GetEventByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("events")
            .push(&request.path.event_hash.to_string());
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get event arguments
    ///
    ///Returns the arguments of a runtime call by its hash.
    ///
    ///GET /events/{event_hash}/args
    pub async fn get_event_args_by_hash(
        &self,
        request: GetEventArgsByHashRequest,
    ) -> anyhow::Result<GetEventArgsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("events")
            .push(&request.path.event_hash.to_string())
            .push("args");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetEventArgsByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get extrinsics
    ///
    ///Returns all extrinsics from the database that satisfy the query parameters. It will return a paginated response, ordered descending by block number and ascending extrinsic index.
    ///
    ///GET /extrinsics
    pub async fn get_extrinsics(
        &self,
        request: GetExtrinsicsRequest,
    ) -> anyhow::Result<GetExtrinsicsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("extrinsics");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetExtrinsicsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get extrinsic by hash
    ///
    ///Returns the extrinsic by its hash.
    ///
    ///GET /extrinsics/{extrinsic_hash}
    pub async fn get_extrinsic_by_hash(
        &self,
        request: GetExtrinsicByHashRequest,
    ) -> anyhow::Result<GetExtrinsicByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("extrinsics")
            .push(&request.path.extrinsic_hash.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetExtrinsicByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get extrinsic root call
    ///
    ///Returns the root call of an extrinsic by its hash.
    ///
    ///GET /extrinsics/{extrinsic_hash}/call
    pub async fn get_extrinsic_root_call_by_hash(
        &self,
        request: GetExtrinsicRootCallByHashRequest,
    ) -> anyhow::Result<GetCallByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("extrinsics")
            .push(&request.path.extrinsic_hash.to_string())
            .push("call");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetExtrinsicRootCallByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get extrinsic calls
    ///
    ///Returns the calls in an extrinsic by extrinsic hash.
    ///
    ///GET /extrinsics/{extrinsic_hash}/calls
    pub async fn get_calls_by_extrinsic_hash(
        &self,
        request: GetCallsByExtrinsicHashRequest,
    ) -> anyhow::Result<GetSubCallsByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("extrinsics")
            .push(&request.path.extrinsic_hash.to_string())
            .push("calls");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetCallsByExtrinsicHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get extrinsic events
    ///
    ///Returns the events in an extrinsic by extrinsic hash.
    ///
    ///GET /extrinsics/{extrinsic_hash}/events
    pub async fn get_events_by_extrinsic_hash(
        &self,
        request: GetEventsByExtrinsicHashRequest,
    ) -> anyhow::Result<GetEventsByExtrinsicHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("extrinsics")
            .push(&request.path.extrinsic_hash.to_string())
            .push("events");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetEventsByExtrinsicHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get genesis records
    ///
    ///Returns a paginated list of all genesis storage records.
    ///
    ///GET /genesis
    pub async fn get_genesis_records(
        &self,
        request: GetGenesisRecordsRequest,
    ) -> anyhow::Result<GetGenesisRecordsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("genesis");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetGenesisRecordsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata list
    ///
    ///Returns a list of metadata summaries for all runtime versions.
    ///
    ///GET /metadata
    pub async fn get_metadata_list(
        &self,
        request: GetMetadataListRequest,
    ) -> anyhow::Result<GetMetadataListResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetMetadataListRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata by spec version
    ///
    ///Returns the metadata by its spec version.
    ///
    ///GET /metadata/{spec_version}
    pub async fn get_metadata(
        &self,
        request: GetMetadataRequest,
    ) -> anyhow::Result<GetMetadataResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata hex
    ///
    ///Returns the SCALE-encoded hexadecimal string for the prefixed metadata.
    ///
    ///GET /metadata/{spec_version}/hex
    pub async fn get_metadata_hex(
        &self,
        request: GetMetadataHexRequest,
    ) -> anyhow::Result<GetMetadataHexResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("hex");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataHexRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata JSON
    ///
    ///Returns the original Substrate runtime metadata by its spec version in JSON representation.
    ///
    ///GET /metadata/{spec_version}/json
    pub async fn get_metadata_json(
        &self,
        request: GetMetadataJsonRequest,
    ) -> anyhow::Result<GetMetadataJsonResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("json");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataJsonRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallets
    ///
    ///Returns pallets in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets
    pub async fn get_metadata_pallets(
        &self,
        request: GetMetadataPalletsRequest,
    ) -> anyhow::Result<GetMetadataPalletsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet
    ///
    ///Returns the full metadata pallet by metadata spec version and pallet index.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}
    pub async fn get_metadata_pallet(
        &self,
        request: GetMetadataPalletRequest,
    ) -> anyhow::Result<GetMetadataPalletResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet calls
    ///
    ///Returns the calls in a pallet in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}/calls
    pub async fn get_metadata_pallet_calls(
        &self,
        request: GetMetadataPalletCallsRequest,
    ) -> anyhow::Result<GetMetadataPalletCallsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string())
            .push("calls");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletCallsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet constants
    ///
    ///Returns the constants in a pallet in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}/constants
    pub async fn get_metadata_pallet_constants(
        &self,
        request: GetMetadataPalletConstantsRequest,
    ) -> anyhow::Result<GetMetadataPalletConstantsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string())
            .push("constants");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletConstantsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet errors
    ///
    ///Returns the errors in a pallet in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}/errors
    pub async fn get_metadata_pallet_errors(
        &self,
        request: GetMetadataPalletErrorsRequest,
    ) -> anyhow::Result<GetMetadataPalletErrorsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string())
            .push("errors");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletErrorsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet events
    ///
    ///Returns the events in a pallet in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}/events
    pub async fn get_metadata_pallet_events(
        &self,
        request: GetMetadataPalletEventsRequest,
    ) -> anyhow::Result<GetMetadataPalletEventsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string())
            .push("events");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletEventsRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get metadata pallet storage items
    ///
    ///Returns the storage items in a pallet in a metadata version.
    ///
    ///GET /metadata/{spec_version}/pallets/{pallet_index}/storage
    pub async fn get_metadata_pallet_storage_items(
        &self,
        request: GetMetadataPalletStorageItemsRequest,
    ) -> anyhow::Result<GetMetadataPalletStorageItemsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("metadata")
            .push(&request.path.spec_version.to_string())
            .push("pallets")
            .push(&request.path.pallet_index.to_string())
            .push("storage");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetMetadataPalletStorageItemsRequest::parse_response(response)
            .await?;
        Ok(parsed)
    }
    ///Get traces
    ///
    ///Returns all traces from the database that satisfy the query parameters. It will return a paginated response, ordered descending by block number, then ascending trace index.
    ///
    ///GET /traces
    pub async fn get_traces(
        &self,
        request: GetTracesRequest,
    ) -> anyhow::Result<GetTracesResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("traces");
        let mut req_builder = self.client.get(url);
        req_builder = req_builder.query(&request.query);
        let response = req_builder.send().await?;
        let parsed = GetTracesRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get trace by hash
    ///
    ///Returns the trace by its hash.
    ///
    ///GET /traces/{trace_hash}
    pub async fn get_trace_by_hash(
        &self,
        request: GetTraceByHashRequest,
    ) -> anyhow::Result<GetTraceByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("traces")
            .push(&request.path.trace_hash.to_string());
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetTraceByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
    ///Get trace value
    ///
    ///Returns the value of a trace record by its hash.
    ///
    ///GET /traces/{trace_hash}/value
    pub async fn get_trace_value_by_hash(
        &self,
        request: GetTraceValueByHashRequest,
    ) -> anyhow::Result<GetTraceValueByHashResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("traces")
            .push(&request.path.trace_hash.to_string())
            .push("value");
        let mut req_builder = self.client.get(url);
        let response = req_builder.send().await?;
        let parsed = GetTraceValueByHashRequest::parse_response(response).await?;
        Ok(parsed)
    }
}

